import 'dart:convert';
import 'dart:developer' as developer;
import '../services/app_logger.dart';
import 'dart:io';
import 'dart:async';
import 'package:http/http.dart' as http;
import '../models/api_response.dart';
import '../models/api_error.dart';

/// Servicio base para peticiones HTTP
class HttpService {
  final String baseUrl;
  String? _token;
  Function()? onSessionExpired;
  Function()? onTokenRefreshNeeded;

  /// Callback para refrescar el token cuando sea necesario
  Function()? get tokenRefreshCallback => onTokenRefreshNeeded;
  set tokenRefreshCallback(Function()? callback) {
    onTokenRefreshNeeded = callback;
  }

  /// Sanitiza el cuerpo para logs, removiendo 'message' y preservando 'messageDetail'
  /// Solo aplica para endpoints de despacho en aduana y creación/listado de cubos
  String _sanitizeBodyForLog(String url, String body) {
    try {
      final lower = url.toLowerCase();
      final isCubeEndpoint = lower.contains('/guide/new-transport-cube') ||
          lower.contains('/guide/get-transport-cubes');
      if (!isCubeEndpoint) return body;
      final dynamic parsed = jsonDecode(body);
      if (parsed is Map<String, dynamic>) {
        // Eliminar message y usar solo messageDetail
        parsed.remove('message');
        final String? md = parsed['messageDetail'] as String?;
        if (md == null || md.isEmpty) {
          parsed.remove('messageDetail');
        }
        return jsonEncode(parsed);
      }
      return body;
    } catch (_) {
      return body; // En caso de error, no romper logs
    }
  }

  HttpService({
    required this.baseUrl,
    this.onSessionExpired,
    this.onTokenRefreshNeeded,
  });

  /// Establece el token de autenticación
  void setToken(String? token) {
    if (token == null || token.trim().isEmpty) {
      _token = null;
      AppLogger.log('Token cleared', source: 'HttpService');
      return;
    }

    // Asegurar formato correcto del token
    _token = token.startsWith('Bearer ') ? token : 'Bearer $token';
    AppLogger.log('Token set: $_token', source: 'HttpService', type: 'AUTH');
  }

  /// Obtiene los headers comunes para las peticiones
  Map<String, String> get _headers => {
    'Content-Type': 'application/json',
    'Accept': 'application/json',
    // setToken ya normaliza el formato a 'Bearer <token>' si fuese necesario
    if (_token != null) 'Authorization': _token!,
  };

  /// Realiza una petición con reintentos de autenticación
  Future<http.Response> _withAuthRetry(
    Future<http.Response> Function() send,
    String requestUrl, {
    bool suppressAuthHandling = false,
  }) async {
    try {
      var response = await send();
      
      // Si se suprime el manejo de auth, retornar directamente
      if (suppressAuthHandling) {
        return response;
      }

      // Si no es 401, retornar directamente
      if (response.statusCode != 401) {
        return response;
      }

      // Si ya intentamos refrescar el token y seguimos recibiendo 401,
      // no intentar de nuevo para evitar ciclos infinitos
      if (_token == null) {
        AppLogger.log(
          'Token is null, skipping refresh attempt',
          source: 'HttpService'
        );
        return response;
      }

      AppLogger.log(
        'Received 401 - Attempting token refresh and retry',
        source: 'HttpService'
      );

      // Intentar refrescar token
      if (onTokenRefreshNeeded != null) {
        final refreshed = await onTokenRefreshNeeded!();
        if (refreshed) {
          AppLogger.log(
            'Token refreshed, retrying request',
            source: 'HttpService'
          );
          // Reintento con el nuevo token
          final retryResponse = await send();
          
          // Si aún así recibimos 401, limpiar token y no reintentar más
          if (retryResponse.statusCode == 401) {
            AppLogger.log(
              'Still getting 401 after token refresh, clearing token',
              source: 'HttpService'
            );
            _token = null;
          }
          
          return retryResponse;
        }
      }

      // Si no hay callback de refresh o falló, proceder con 401
      AppLogger.log(
        'Token refresh failed or not available',
        source: 'HttpService'
      );
      
      // Limpiar token si el refresh falló
      _token = null;
      return response;

    } catch (e) {
      AppLogger.error(
        'Error in auth retry mechanism',
        error: e,
        source: 'HttpService'
      );
      rethrow;
    }
  }

  /// Realiza una petición GET
  /// 
  /// [suppressAuthHandling] determina el comportamiento ante errores de autenticación:
  /// - Si es false (default): limpia el token y llama a [onSessionExpired]
  /// - Si es true: retorna el error pero mantiene la sesión activa
  /// 
  /// Este parámetro es útil cuando necesitas manejar los errores 401/SESSION_EXPIRED 
  /// de forma personalizada en la UI sin cerrar la sesión automáticamente.
  Future<ApiResponse<T>> get<T>(
    String path,
    T Function(Map<String, dynamic> json) fromJson, {
    Map<String, dynamic>? queryParams,
    bool suppressAuthHandling = false,
  }) async {
    try {
      final uri = Uri.parse(baseUrl + path).replace(
        queryParameters: queryParams?.map(
          (key, value) => MapEntry(key, value.toString()),
        ),
      );
      
      AppLogger.log(
        'Making GET request to: ${uri.toString()}\nParams: $queryParams',
        source: 'HttpService'
      );

      final client = http.Client();
      final response = await _withAuthRetry(
        () => client.get(uri, headers: _headers)
          .timeout(const Duration(seconds: 30)),
        uri.toString(),
        suppressAuthHandling: suppressAuthHandling,
      );
      AppLogger.apiCall(
        uri.toString(),
        method: 'GET',
      );
      final sanitizedBody = _sanitizeBodyForLog(uri.toString(), response.body);
      AppLogger.apiResponse(
        uri.toString(),
        statusCode: response.statusCode,
        body: sanitizedBody,
      );

      if (response.statusCode == 401) {
        AppLogger.error(
          'Received 401 Unauthorized response',
          source: 'HttpService',
          error: 'Session expired',
        );
        final error = ApiError.sessionExpired();
        
        if (!suppressAuthHandling) {
          _token = null;
          await Future(() {
            onSessionExpired?.call();
          });
        } else {
          AppLogger.log(
            'Skipping token cleanup due to suppressAuthHandling',
            source: 'HttpService'
          );
        }
        
        return ApiResponse.error(
          messageDetail: error.userMessage,
          content: null,
        );
      }

      Map<String, dynamic> json;
      try {
        // Intentar parsear la respuesta del backend
        json = jsonDecode(response.body) as Map<String, dynamic>;
      } catch (_) {
        // Si no podemos parsear, devolver la respuesta tal cual del backend
        return ApiResponse.error(
          messageDetail: response.body,
          content: null
        );
      }

      final code = json['code'] as int? ?? ApiErrorCode.SERVER_ERROR;
      final message = json['message'] as String? ?? '';
      final messageDetail = json['messageDetail'] as String?;

      // Si el backend respondió sesión expirada en el body
      if (code == ApiErrorCode.SESSION_EXPIRED || code == ApiErrorCode.INVALID_TOKEN) {
        developer.log('Auth error in body code ($code): $messageDetail', name: 'HttpService');
        
        if (!suppressAuthHandling) {
          _token = null;
          await Future(() {
            onSessionExpired?.call();
          });
          return ApiResponse.error(message: ApiError.sessionExpired().userMessage);
        } else {
          AppLogger.log(
            'Returning error but keeping session due to suppressAuthHandling',
            source: 'HttpService'
          );
          return ApiResponse.error(
            message: json['message'] ?? 'Error de autenticación',
            content: null,
          );
        }
      }

      // Si el código no es 0 (éxito) o 1 (warning), es un error
      if (code > 1) {
        final error = ApiError(code: code, message: messageDetail ?? '');
        return ApiResponse.error(message: error.userMessage);
      }

      // Aquí ya sabemos que la respuesta es exitosa
      // Si el mensaje es el de éxito por defecto, moverlo a messageDetail
      final mDetail = message == 'Su transacción fue realizada con éxito (0)'
          ? message // Usar el mensaje genérico como messageDetail
          : messageDetail;
      
      return ApiResponse(
        isSuccessful: true,
        message: null, // No usar message para mensajes de éxito
        messageDetail: mDetail,
        content: fromJson(json),
      );
    } catch (e) {
      final error = _handleError(e);
      developer.log('Error en GET request: ${error.message}', name: 'HttpService', error: e);
      return ApiResponse.error(message: error.userMessage);
    }
  }

  /// Realiza una petición POST
  /// 
  /// [suppressAuthHandling] determina el comportamiento ante errores de autenticación:
  /// - Si es false (default): limpia el token y llama a [onSessionExpired]
  /// - Si es true: retorna el error pero mantiene la sesión activa
  /// 
  /// Este parámetro es útil cuando necesitas manejar los errores 401/SESSION_EXPIRED 
  /// de forma personalizada en la UI sin cerrar la sesión automáticamente.
  Future<ApiResponse<T>> post<T>(
    String path,
    dynamic data,
    T Function(Map<String, dynamic> json) fromJson, {
    bool suppressAuthHandling = false,
  }) async {
    AppLogger.log(
      'HTTP POST Request:\n'
      'URL: $baseUrl$path\n'
      'Headers: $_headers\n'
      'Body: ${jsonEncode(data)}',
      source: 'HttpService'
    );

    try {
      final client = http.Client();
      final response = await _withAuthRetry(
        () => client.post(
          Uri.parse(baseUrl + path),
          headers: _headers,
          body: jsonEncode(data),
        ).timeout(const Duration(seconds: 30)),
        baseUrl + path,
        suppressAuthHandling: suppressAuthHandling,
      );

      developer.log('Response Status: ${response.statusCode}', name: 'HttpService');
      final sanitizedBody = _sanitizeBodyForLog(baseUrl + path, response.body);
      developer.log('Response Body: $sanitizedBody', name: 'HttpService');

      if (response.statusCode == 401) {
        AppLogger.error(
          'Authentication error: 401 Unauthorized',
          source: 'HttpService',
          error: 'Session expired',
        );
        final error = ApiError.sessionExpired();
        if (!suppressAuthHandling) {
          _token = null;
          await Future(() {
            onSessionExpired?.call();
          });
        } else {
          AppLogger.log(
            'Skipping token cleanup due to suppressAuthHandling',
            source: 'HttpService'
          );
        }
        return ApiResponse.error(
          message: error.userMessage,
          content: null,
        );
      }

      Map<String, dynamic> json;
      try {
        json = jsonDecode(response.body) as Map<String, dynamic>;
      } catch (_) {
        return ApiResponse.error(message: ApiError.serverError('Respuesta inválida del servidor').userMessage);
      }

      final code = json['code'] as int? ?? ApiErrorCode.SERVER_ERROR;
      final message = json['message'] as String? ?? '';
      final messageDetail = json['messageDetail'] as String?;

      // Manejar código especial (60): tratar como éxito PERO conservar el contenido del backend
      if (message.contains('(60)')) {
        return ApiResponse(
          isSuccessful: true,
          message: message,
          messageDetail: messageDetail,
          content: fromJson(json),
        );
      }

      // Si el backend respondió sesión expirada en el body
      if (code == ApiErrorCode.SESSION_EXPIRED || code == ApiErrorCode.INVALID_TOKEN) {
        developer.log('Auth error detected: $message', name: 'HttpService');
        
        if (!suppressAuthHandling) {
          _token = null;
          await Future(() {
            onSessionExpired?.call();
          });
          return ApiResponse.error(message: ApiError.sessionExpired().userMessage);
        } else {
          AppLogger.log(
            'Returning error but keeping session due to suppressAuthHandling',
            source: 'HttpService'
          );
          return ApiResponse.error(
            message: json['message'] ?? 'Error de autenticación',
            content: null,
          );
        }
      }

      // Si el código no es 0 (éxito) o 1 (warning), es un error
      if (code > 1) {
        // Para errores, priorizar siempre messageDetail
        return ApiResponse.error(
          message: messageDetail ?? message,
          messageDetail: messageDetail
        );
      }

      // Aquí ya sabemos que la respuesta es exitosa
      return ApiResponse(
        isSuccessful: true,
        message: message,
        messageDetail: messageDetail,
        content: fromJson(json),
      );
    } catch (e) {
      final error = _handleError(e);
      developer.log('Error en POST request: ${error.message}', name: 'HttpService', error: e);
      return ApiResponse.error(message: error.userMessage);
    }
  }

  /// Realiza una petición PUT
  /// 
  /// [suppressAuthHandling] determina el comportamiento ante errores de autenticación:
  /// - Si es false (default): limpia el token y llama a [onSessionExpired]
  /// - Si es true: retorna el error pero mantiene la sesión activa
  /// 
  /// Este parámetro es útil cuando necesitas manejar los errores 401/SESSION_EXPIRED 
  /// de forma personalizada en la UI sin cerrar la sesión automáticamente.
  Future<ApiResponse<T>> put<T>(
    String path,
    dynamic data,
    T Function(Map<String, dynamic> json)? fromJson, {
    bool suppressAuthHandling = false,
  }) async {
    developer.log('HTTP PUT Request', name: 'HttpService');
    developer.log('URL: $baseUrl$path', name: 'HttpService');
    developer.log('Headers: $_headers', name: 'HttpService');
    developer.log('Body: ${jsonEncode(data)}', name: 'HttpService');

    try {
      final client = http.Client();
      final response = await _withAuthRetry(
        () => client.put(
          Uri.parse(baseUrl + path),
          headers: _headers,
          body: jsonEncode(data),
        ).timeout(const Duration(seconds: 30)),
        baseUrl + path,
        suppressAuthHandling: suppressAuthHandling,
      );

      developer.log('Response Status: ${response.statusCode}', name: 'HttpService');
      developer.log('Response Body: ${response.body}', name: 'HttpService');

      if (response.statusCode == 401) {
        AppLogger.error(
          'Authentication error: 401 Unauthorized',
          source: 'HttpService',
          error: 'Session expired',
        );
        final error = ApiError.sessionExpired();
        if (!suppressAuthHandling) {
          _token = null;
          await Future(() {
            onSessionExpired?.call();
          });
        } else {
          AppLogger.log(
            'Skipping token cleanup due to suppressAuthHandling',
            source: 'HttpService'
          );
        }
        return ApiResponse.error(
          message: error.userMessage,
          content: null,
        );
      }

      Map<String, dynamic> json;
      try {
        json = jsonDecode(response.body) as Map<String, dynamic>;
      } catch (_) {
        return ApiResponse.error(message: ApiError.serverError('Respuesta inválida del servidor').userMessage);
      }

      final code = json['code'] as int? ?? ApiErrorCode.SERVER_ERROR;
      final message = json['message'] as String? ?? '';
      final messageDetail = json['messageDetail'] as String?;

      // Si el código no es 0 (éxito) o 1 (warning), es un error
      if (code > 1) {
        final error = ApiError(code: code, message: messageDetail ?? message);
        developer.log(
          'API Error:\n- Code: $code\n- Message: $message\n- Detail: $messageDetail',
          name: 'HttpService',
          error: error,
        );
        return ApiResponse.error(message: error.userMessage);
      }

      // Aquí ya sabemos que la respuesta es exitosa
      // Si el mensaje es el de éxito por defecto, moverlo a messageDetail
      final mDetail = message == 'Su transacción fue realizada con éxito (0)'
          ? message // Usar el mensaje genérico como messageDetail
          : messageDetail;
      
      return ApiResponse(
        isSuccessful: true,
        message: null, // No usar message para mensajes de éxito
        messageDetail: mDetail,
        content: fromJson != null ? fromJson(json) : null,
      );
    } catch (e) {
      final error = _handleError(e);
      developer.log('Error en PUT request: ${error.message}', name: 'HttpService', error: e);
      return ApiResponse.error(message: error.userMessage);
    }
  }

  /// Maneja errores comunes y los convierte en ApiError
  ApiError _handleError(Object e) {
    developer.log('Error HTTP: $e', name: 'HttpService');
    
    if (e is SocketException) {
      return ApiError(
        code: ApiErrorCode.NETWORK_ERROR,
        message: 'Error de conexión: ${e.message}',
      );
    }
    
    if (e is TimeoutException) {
      return ApiError(
        code: ApiErrorCode.TIMEOUT,
        message: 'La solicitud ha tardado demasiado tiempo',
      );
    }
    
    if (e is FormatException) {
      return ApiError(
        code: ApiErrorCode.SERVER_ERROR,
        message: 'Error al procesar la respuesta del servidor',
      );
    }
    
    return ApiError(
      code: ApiErrorCode.UNKNOWN,
      message: e.toString(),
    );
  }
}